# Miscellaneous SuiteScript 2.0 high level utilities and APIs

(mostly oriented to Commerce)

# What

 * SuiteScript 2.0 types thanks to project @hitc/netsuite-types
 * basic developer tools to watch/build/deploy changes (`npm run dev`)
 * Besides the types, this package contains some useful tools that can be imported and used from pure JavaScript projects.

## Features

(so far)

 * **TypedRecord** - Record fields and sublists are strongly typed for fieldId and sublistId only of that record type. Example: when you load a 'customer' record setValue() and setSublistValue() calls will validate that fieldId and sublistId belong to record type 'customer. It uses types generated by metadataFromRecordBrowser (auto generated from record browser html pages). It only declare types - it doesn't implement any wrapper around the native objects so it virtually weights 0%. See src/record/typedRecord. 
 * **TypedSearch** - Search creation and results are strongly typed against the record type. For example, when you create a search of type: 'item', given columns, filters and join names are validated against that record type ("item"). Also filter operators are validated to be of the filter type supported operators only. It only declare types - it doesn't implement any wrapper around the native objects so it virtually weights 0%. See src/search/typedSearch. 
 * **spec framework implementation** from scratch. Write TDD tests like with jasmine/jest/mocha using describe(), expect(), it() etc and run them on NetSuite. Very basic but working support to test your code IN NetSuite and in node.js
 * **TSX/JSX** for server side markup render support. Use TSX/JSX to render HTML in the server. Markup using TSX is strongly typed !. Implements JSX.Element and createElement() that render elements to string, very lightweight - no library required. See src/jsx
 * **Logger interface ResponseLogger implementation** so is easy to debug when using SuiteLet, RestLet. Global console.log (and imt/timeEnd/error/warn) implemented. See src/log
 * **Record copy utilities**: copyFields, copySublist, copySublists. See src/record/copy
 * Commerce related utilities: 
   * **copyCategory, moveCategory, removeCategory** : to copy/move commercecategory to another parent or remove it
   * matrix item utils (to see or find if an item is matrix parent, child, or non )
 * **Array.prototype.filter** polly fill. see src/misc/misc
 * **file cabinet high level operations** like ls, glob, mkdirp, find. See src/file

## Other features

 * **Easy to use devtools** to watch, compile and deploy to filecabinet automatically. Support uploading only changed files (local file hash). See `npm run dev`and devtools/dev.
 * **metadataFromRecordBrowser** : tools to extract all record's metadata from online (or offline) record browser pages and generate typescript types. see ./metadataFromRecordBrowser
   * **metadataFromRecordBrowser/metadataFromRecordBrowser.js** - snippet that can be run on a record browser page to extract record's metadata such as fields, sublists, search columns, filters, joins, etc
   * **metadataFromRecordBrowser/extractMetadataFromZip** : tool based on puppeteer (headless browser) to navigate throu all record browser' pages and execute metadataFromRecordBrowser.js to extract all record's metadata. For each record it will generate a .json file
   * **metadataFromRecordBrowser/tsGenerator** will generate TypeScript files with interfaces describing each record metadata, as well as general interfaces describing which interface describe which record type, etc. (these types are consumed then by typedSearch and TypedRecord)

# Usage

 * `npm run build` will generate usable SuiteScript 2.0 .files that you can copy to your project and import it (if you are working with pure .js)
 * `npm run dev` to develop:

# Usage details: 

If you are working with TypeScript, then is better to clone this repository, start your feature in src/ and import the utilities. Just make sure that:
 * Configure account, target folder, role, applicationId, etc in ./config.js file (this information is needed to deploy the generated scripts to NetSuite)
 * the first time you run it it will ask you for your email / password and this information will be stored in $(HOME)/netsuite_creds.js
will:
 * make sure all your imports are relative, i.e : `import { copySublist } from '../record/copy/copySublist';`
 * import SuiteScript types like this: `import * as record from 'N/record';`
 * don't make radical changes in tsconfig.json since it needs that particular configuration in order the emitted .js to work
 * you will need to create the output folder structure manually in the file cabinet (by default SuiteScript folder) and upload script entry point manually.
 * ./src/suitelet-sample1.ts is a SuiteLet entry point example
 * ./src/user-event-sample1.ts is a user event entry point example 

# Limitations
 
 * You need to respect current tsconfig.json
 * always import files using **exact relative names**: 
   * Don't use index.ts shortcut, i.e: `from "../some/folder/index"` will work . `from "../some/folder"` wont
   configure your editor to always create/suggest/fix imports as relatives, for example in vscode settings: "Typescript â€º Preferences: Import Module Specifier. Preferred path style for auto imports. == RELATIVE" 
 * you can use all ecma syntax features but promises/await/async since NetSuite don't support setTimeout()


# Objectives (short term)

 * API to move/copy/remove categories (and all descendants)
 * API to complex query items, example: all items that belong to categories A and B and which custom field C contains the string "D"

# Objectives (long term)

 * long term: administer all the aspects of a catalog (items, categories, facets, reviews, lists, etc)
 * higher level Record interface wrapping current Record. Then subclasses for Item, Category, etc


# TODO

 * gulp uploads all files at startup - a cheap solution is to store hash of those uploaded to see if they changed and only upload them if so
 * memorize for test preconditions
 * maybe we can create an API that we can use to access filesystem, instead of suitetalk, like mkdir -p , write, read, globs, etc
 * be able to run specs (jasmine/jest like API if possible)
 * create folder structure in file cabinet automatically
 * upload the entry point script at last to prevent errors. 
 * (for devtools) we could separate tslib.js so emitted files are smaller
 * fix credentials storing at $(HOME)/netsuite_creds.js - always ask for password and never save it.
 * research: browserify and have a single .js bundle? this would simplify the deploy ? Dont' know
 * mode script entry point examples (schedule, restlet, client)
